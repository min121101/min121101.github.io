<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Minmin">
<meta property="og:url" content="http://minmin.com/index.html">
<meta property="og:site_name" content="Minmin">
<meta property="og:locale">
<meta property="article:author" content="Minmin">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://minmin.com/"/>





  <title>Minmin</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Minmin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://minmin.com/2021/12/03/numpy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Minmin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/03/numpy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url">numpy学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-12-03T14:16:10+08:00">
                2021-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">数据分析基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Numpy学习笔记"><a href="#Numpy学习笔记" class="headerlink" title="Numpy学习笔记"></a>Numpy学习笔记</h1><h2 id="通过dtype定义类型"><a href="#通过dtype定义类型" class="headerlink" title="通过dtype定义类型"></a>通过dtype定义类型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建列表</span></span><br><span class="line"><span class="comment">#dtype 定义类型</span></span><br><span class="line">a = np.array([<span class="number">2</span>,<span class="number">23</span>,<span class="number">234</span>],dtype = np.float64)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a.dtype)</span><br></pre></td></tr></table></figure>
<h2 id="定义矩阵"><a href="#定义矩阵" class="headerlink" title="定义矩阵"></a>定义矩阵</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义矩阵</span></span><br><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">            [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment">#生成0矩阵</span></span><br><span class="line">c = np.zeros((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment">#生成1矩阵</span></span><br><span class="line">d = np.ones((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment">#生成空矩阵</span></span><br><span class="line">e = np.empty((<span class="number">4</span>,<span class="number">6</span>)) <span class="comment">#这里的empty是指数值无限接近于0的数</span></span><br><span class="line"><span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure>
<h2 id="生成有序数列"><a href="#生成有序数列" class="headerlink" title="生成有序数列"></a>生成有序数列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成有序数列</span></span><br><span class="line">a = np.arange(<span class="number">1</span>,<span class="number">20</span>,<span class="number">5</span>) <span class="comment">#生成1到20步长为5的数列</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">b = np.linspace(<span class="number">1</span>,<span class="number">20</span>,<span class="number">5</span>)<span class="comment">#生成将1到20分为五段的数列</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">b = np.linspace(<span class="number">2</span>,<span class="number">30</span>,<span class="number">6</span>).reshape((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<h2 id="numpy的基本运算"><a href="#numpy的基本运算" class="headerlink" title="numpy的基本运算"></a>numpy的基本运算</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">b = np.arange(<span class="number">1</span>,<span class="number">9</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">c = a - b<span class="comment">#两个列表各元素相减</span></span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">d = a + b<span class="comment">#两个列表各元素相加</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="built_in">print</span>(a**<span class="number">2</span>)<span class="comment">#a的平方</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span>*np.sin(a))<span class="comment">#列表各元素取sin后乘10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#形成布尔列表</span></span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(a&lt;<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a==<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line">b = np.arange(<span class="number">4</span>).reshape((<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(a*b)<span class="comment">#矩阵中各元素相乘</span></span><br><span class="line"><span class="built_in">print</span>(np.dot(a,b))<span class="comment">#矩阵乘法运算</span></span><br><span class="line"><span class="built_in">print</span>(a.dot(b))<span class="comment">#这个也是矩阵乘法运算</span></span><br><span class="line"></span><br><span class="line">a = np.random.random((<span class="number">3</span>,<span class="number">3</span>))<span class="comment">#生成3*3的随机矩阵</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">sum</span>())<span class="comment">#矩阵各元素相加和</span></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(a))</span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">sum</span>(axis=<span class="number">1</span>))<span class="comment">#矩阵各列元素相加和返回一个行向量</span></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(a,axis=<span class="number">0</span>))<span class="comment">#矩阵各行元素相加返回一个列向量</span></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">max</span>(a))<span class="comment">#矩阵中最大值</span></span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">min</span>())<span class="comment">#矩阵中最小值</span></span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">11</span>,-<span class="number">1</span>,-<span class="number">1</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(np.argmin(a))<span class="comment">#返回最小值索引</span></span><br><span class="line"><span class="built_in">print</span>(a.argmax())<span class="comment">#返回最大值索引</span></span><br><span class="line"><span class="built_in">print</span>(a.mean())<span class="comment">#求矩阵所有元素和的平均值</span></span><br><span class="line"><span class="comment">#mean方法，也可以用axis参数对行之间，或者对列之间求平均数</span></span><br><span class="line"><span class="built_in">print</span>(np.average(a))<span class="comment">#求矩阵所有元素和的平均值</span></span><br><span class="line"><span class="built_in">print</span>(np.median(a))<span class="comment">#输出矩阵各元素的中位数</span></span><br><span class="line"><span class="built_in">print</span>(np.cumsum(a))<span class="comment">#返回一个逐步累加的数列，数列长度等于元素个数</span></span><br><span class="line"><span class="built_in">print</span>(np.diff(a))<span class="comment">#返回一个后一位与本位的差的矩阵</span></span><br><span class="line"><span class="built_in">print</span>(np.nonzero(a))<span class="comment">#返回非0数据的一组行向量（含第几行）和一组列向量（含第几列），是分开的</span></span><br><span class="line"><span class="built_in">print</span>(np.sort(a))<span class="comment">#对数组的每一行进行从大到小排序，上下位置不互通</span></span><br><span class="line"><span class="built_in">print</span>(np.transpose(a))<span class="comment">#矩阵的转置</span></span><br><span class="line"><span class="built_in">print</span>(a.T)<span class="comment">#矩阵的转置</span></span><br><span class="line"><span class="built_in">print</span>(np.clip(a,<span class="number">3</span>,<span class="number">8</span>))<span class="comment">#小于3的变成3，大于8的变成8</span></span><br></pre></td></tr></table></figure>
<h2 id="numpy索引"><a href="#numpy索引" class="headerlink" title="numpy索引"></a>numpy索引</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">3</span>,<span class="number">15</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>])<span class="comment">#索引第三行</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>][<span class="number">1</span>])<span class="comment">#索引第二行第二列</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>,<span class="number">1</span>])<span class="comment">#和上面一样的</span></span><br><span class="line"><span class="built_in">print</span>(a[:,<span class="number">2</span>])<span class="comment">#索引第三列的所有数</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>,<span class="number">1</span>:<span class="number">3</span>])<span class="comment">#返回第二行的第2到3列</span></span><br></pre></td></tr></table></figure>
<h2 id="numpy迭代"><a href="#numpy迭代" class="headerlink" title="numpy迭代"></a>numpy迭代</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">3</span>,<span class="number">15</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(row)<span class="comment">#迭代矩阵a的每一行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> column <span class="keyword">in</span> a.T:</span><br><span class="line">    <span class="built_in">print</span>(column)<span class="comment">#迭代矩阵a的每一列</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> a.flat:</span><br><span class="line">    <span class="comment">#a.flat将a矩阵变为一个迭代器</span></span><br><span class="line">    <span class="built_in">print</span>(item)<span class="comment">#迭代矩阵a的每一个元素</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(a.flatten())<span class="comment">#a.flatten将a矩阵变为一个行向量</span></span><br></pre></td></tr></table></figure>
<h2 id="numpy进行矩阵合并"><a href="#numpy进行矩阵合并" class="headerlink" title="numpy进行矩阵合并"></a>numpy进行矩阵合并</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]])</span><br><span class="line">b = np.array([[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]]) </span><br><span class="line"><span class="built_in">print</span>(a.shape)<span class="comment">#当一个矩阵为行向量或者列向量时他的shape是（x,），x代表元素个数</span></span><br><span class="line"><span class="built_in">print</span>(np.vstack((a,b)))<span class="comment">#上下合并</span></span><br><span class="line"><span class="built_in">print</span>(np.hstack((a,b)))<span class="comment">#左右合并</span></span><br><span class="line"><span class="built_in">print</span>(a[:,np.newaxis])<span class="comment">#增加一个维度并且转置</span></span><br><span class="line"><span class="built_in">print</span>(np.concatenate((a,b,a,b),axis=<span class="number">0</span>))<span class="comment">#axis可以指定这些矩阵是上下合并还是左右合并</span></span><br><span class="line"><span class="built_in">print</span>(np.concatenate((a,b),axis=<span class="number">1</span>))<span class="comment">#axis可以指定这些矩阵是上下合并还是左右合并</span></span><br><span class="line"><span class="comment">#但是concatenate方法要在二维以上的矩阵才能合并</span></span><br></pre></td></tr></table></figure>
<h2 id="numpy进行矩阵拆分"><a href="#numpy进行矩阵拆分" class="headerlink" title="numpy进行矩阵拆分"></a>numpy进行矩阵拆分</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(np.split(a,<span class="number">2</span>,axis=<span class="number">1</span>))<span class="comment">#将a以列为单位分成两部分</span></span><br><span class="line"><span class="built_in">print</span>(np.split(a,<span class="number">3</span>,axis=<span class="number">0</span>))<span class="comment">#将a以行为单位分成三部分</span></span><br><span class="line"><span class="built_in">print</span>(np.hsplit(a,<span class="number">2</span>))<span class="comment">#将a以列为单位分成两部分</span></span><br><span class="line"><span class="built_in">print</span>(np.vsplit(a,<span class="number">3</span>))<span class="comment">#将a以行为单位分成三部分</span></span><br><span class="line"><span class="comment">#需要注意的是不管按列还是按行，分成n部分，n需要能整除行数列数</span></span><br><span class="line"><span class="built_in">print</span>(np.array_split(a,<span class="number">2</span>,axis=<span class="number">0</span>))<span class="comment">#将a以行为单位分成两部分（不均等分割）</span></span><br></pre></td></tr></table></figure>
<h2 id="numpy的copy"><a href="#numpy的copy" class="headerlink" title="numpy的copy"></a>numpy的copy</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">b = a</span><br><span class="line"><span class="built_in">print</span>(b <span class="keyword">is</span> a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">44</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)<span class="comment">#可以发现 a = b是将ab关联起来的赋值，改变一个另一个也会变</span></span><br><span class="line"><span class="comment">#若不想将ab关联赋值，则可以</span></span><br><span class="line">b = a.copy()</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://minmin.com/2021/12/03/AdaBoost%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Minmin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/03/AdaBoost%E7%AE%97%E6%B3%95/" itemprop="url">AdaBoost算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-12-03T13:00:30+08:00">
                2021-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="AdaBoost算法"><a href="#AdaBoost算法" class="headerlink" title="AdaBoost算法"></a>AdaBoost算法</h1><h2 id="强可学习和弱可学习的定义"><a href="#强可学习和弱可学习的定义" class="headerlink" title="强可学习和弱可学习的定义"></a>强可学习和弱可学习的定义</h2><ol>
<li>强可学习说的是，在概率近似正确的PAC学习框架中，一个概念，如果存在一个多项式的学习算法去学习它，并且正确率很高，那么这个概念我们称之为强可学习的。</li>
<li>一个概念，如果存在一个多项式的学习算法去学习它，但是它的正确率仅仅比随机猜测略好，那么我们称它为弱可学习的。</li>
<li>在PAC学习的框架下，一个概念是强可学习的充要条件是这个概念是弱可学习。</li>
</ol>
<h2 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h2><p>只要找到一个比随机猜测略好的弱学习算法就可以直接将其提升为强学习算法，而不必直接去找很难获得的强学习算法，也就是不需要直接寻找强学习算法，而是通过提升弱学习的方法使他达到强学习算法的目的。</p>
<p>那么我们该如何实现弱学习转为强学习呢？</p>
<p>答案是：如果A算法在a情况下失效，B算法在b情况下失效，那么我们可以在a情况下用B算法，同理我们可以在b情况下用A算法，以此来解决问题，也就是说我们可以通过某种方式将各种算法组合起来解决单一弱算法解决不了的问题，以此来提高正确率。</p>
<p>那我们又面临两个问题了：</p>
<ol>
<li>怎么获得不同的弱分类器？</li>
<li>怎么将这些弱分类器组合起来呢？</li>
</ol>
<p>对于问题1：我们可以使用不同的弱学习算法，有如参数估计，非参数估计等等；又或是使用相同的弱学习算法但选用不同的参数，比如K-means的K值，神经网络的隐藏层；还有输入对象的不同表示凸显事物不同的特征；或者使用不同的训练集。</p>
<p>对于问题2：</p>
<ol>
<li>第一种是使用多专家组合，这是一种并行结构，例如随机森林，是多棵决策树平行投票表决的，然后输出最终的众数结果；</li>
<li>第二种是多级组合，这是一种串行结构，其中下一个分类器，只对前一个分类器预测不准确的实例（即困难样本）进行训练和检测纠正。</li>
</ol>
<h2 id="AdaBoost算法原理"><a href="#AdaBoost算法原理" class="headerlink" title="AdaBoost算法原理"></a>AdaBoost算法原理</h2><h3 id="AdaBoost的解释"><a href="#AdaBoost的解释" class="headerlink" title="AdaBoost的解释"></a>AdaBoost的解释</h3><p>首先AdaBoost就是上面提到的多级组合,是一种串行结构。是一种前人栽树后人乘凉的算法。他由多个弱分类器组成，然后形成一个强分类器，对数据集的预测有泛化功能，准确性高。</p>
<h3 id="AdaBoost算法需要解决的两个问题"><a href="#AdaBoost算法需要解决的两个问题" class="headerlink" title="AdaBoost算法需要解决的两个问题"></a>AdaBoost算法需要解决的两个问题</h3><ol>
<li><p>每一轮如何改变训练数据的权值或者概率分布？</p>
<p>AdaBoost：如何提高前一轮弱分类器错误分类样本的权值；降低正确分类样本的权值。</p>
</li>
<li><p>如何将若干个弱分类器组合成强分类器？</p>
<p>AdaBoost：加权多数表决，加大分类误差率小的若分类器的权值，使其在分类表决时起较大的作用，减小分类误差率大的弱分类器的权值，使其在表决时起较小的作用。</p>
</li>
</ol>
<h3 id="AdaBoost算法过程"><a href="#AdaBoost算法过程" class="headerlink" title="AdaBoost算法过程"></a>AdaBoost算法过程</h3><ol>
<li><p>计算样本权重，有权重向量D，将权重向量D初始化为相等值，假设我们有n个训练集：</p>
<script type="math/tex; mode=display">
\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \ldots,\left(x_{n}, y_{n}\right)\right\}</script><p>设定每个样本的权重都相等，则权重为$\frac{1}{n}$</p>
</li>
<li><p>计算错误率</p>
<p>在训练集上训练出一个弱分类器，并计算分类器的错误率：</p>
<script type="math/tex; mode=display">
\epsilon=\frac{分错的数量}{样本总数}</script></li>
<li><p>计算弱分类器权重</p>
<p>为当前分类器赋予权重值alpha，alpha的计算公式为：</p>
<script type="math/tex; mode=display">
\alpha=\frac{1}{2} \ln \left(\frac{1-\epsilon}{\epsilon}\right)</script></li>
<li><p>调整权重值</p>
<p>根据上一次训练结果，调整权重值（上一次分对的权重降低，分错的权重增加）</p>
<p>如果第i个样本被正确分类，则该样本权重更改为：</p>
<script type="math/tex; mode=display">
D_{i}^{(t+1)}=\frac{D_{i}^{(t)} e^{-\alpha}}{\operatorname{Sum}(D)}</script><p>如果第i个样本被分错，则该样本权重更改为：</p>
<script type="math/tex; mode=display">
D_{i}^{(t+1)}=\frac{D_{i}^{(t)} e^{\alpha}}{\operatorname{Sum}(D)}</script><p>之后，在同一数据集上再一次训练弱分类器，然后循环上述过程，直到训练错误率为0，或者弱分类器的数目达到</p>
<p>指定值。</p>
</li>
</ol>
<p>以上就是AdaBoost算法的步骤</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://minmin.com/2021/12/03/SVM%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BB%A3%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Minmin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/03/SVM%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BB%A3%E7%A0%81/" itemprop="url">SVM原理及代码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-12-03T12:48:23+08:00">
                2021-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SVM原理及代码"><a href="#SVM原理及代码" class="headerlink" title="SVM原理及代码"></a>SVM原理及代码</h1><h2 id="先复习一下感知机"><a href="#先复习一下感知机" class="headerlink" title="先复习一下感知机"></a>先复习一下感知机</h2><ul>
<li><p>感知机的模型就是尝试找到一条直线，能够把二元数据隔离开。放到三维空间或者更高维的空间，感知机的模型就是尝试找到一个超平面，能够把所有的二元类别隔离开。</p>
</li>
<li><p><img src="https://images2015.cnblogs.com/blog/1042406/201611/1042406-20161124135616081-623185925.jpg" alt="img"></p>
<p>我们需要找到最优的$w^Tx+b=0$使得该超平面分隔数据。</p>
</li>
<li><p>定义一下我们的损失函数$\sum_{xi∈M}^{} −y(i)(w^T x(i)+b)/||w||_2$</p>
<p>固定$||w||_2 = 1$最终感知机的模型损失函数为：$\sum_{xi∈M}^{} −y(i)(w^T x(i)+b)$</p>
<p>优化上面的损失函数就可以找到最优的超平面来分隔开数据。</p>
</li>
</ul>
<h2 id="支持向量"><a href="#支持向量" class="headerlink" title="支持向量"></a>支持向量</h2><ul>
<li><p>我们可以让离超平面比较近的点尽可能的远离超平面，最大化几何间隔，那么我们的分类效果会更好一些，SVM的思想起源正起于此。</p>
</li>
<li><p><img src="https://images2015.cnblogs.com/blog/1042406/201611/1042406-20161124144326487-1331861308.jpg" alt="img"></p>
<p>分离超平面为$w^T x+b=0$，如果所有的样本不光可以被超平面分开，还和超平面保持一定的函数距离（上图函数距离为1），那么这样的分类超平面是比感知机的分类超平面优的。</p>
<p>支持向量到超平面的距离为$\frac{1}{||w||_2} $,两个支持向量之间的距离为$\frac{2}{||w||_2} $。</p>
</li>
</ul>
<h2 id="SVM模型目标函数与优化"><a href="#SVM模型目标函数与优化" class="headerlink" title="SVM模型目标函数与优化"></a>SVM模型目标函数与优化</h2><script type="math/tex; mode=display">
\begin{aligned}
\max _{\boldsymbol{w}, b} & \frac{2}{\|\boldsymbol{w}\|} \\
\text { s.t. } & y_{i}\left(\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}_{i}+b\right) \geqslant 1, \quad i=1,2, \ldots, m
\end{aligned}</script><p>上式就是我们要求解的最大化间隔的约束条件和公式，显然，为了最大化间隔隔，仅需最大化$|\boldsymbol{w}|^{-1}$ ，这等价于最小化$|\boldsymbol{w}|^{2}$，于是上式可以重写为：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\min _{\boldsymbol{w}, b} \frac{1}{2}\|\boldsymbol{w}\|^{2} \\
\text { s.t. } y_{i}\left(\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}_{i}+b\right) \geqslant 1, \quad i=1,2, \ldots, m
\end{array}</script><p>这就是支持向量机的基本型。</p>
<p>使用拉格朗日乘子法可得到其”对偶问题” (dual problem).具体来说，对上式的每条约束添加拉格朗日乘子$\alpha_{i} \geqslant 0$，则该问题的拉格朗日函数可写为：</p>
<script type="math/tex; mode=display">
L(\boldsymbol{w}, b, \boldsymbol{\alpha})=\frac{1}{2}\|\boldsymbol{w}\|^{2}+\sum_{i=1}^{m} \alpha_{i}\left(1-y_{i}\left(\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}_{i}+b\right)\right)</script><p>其中$\boldsymbol{\alpha}=\left(\alpha_{1} ; \alpha_{2} ; \ldots ; \alpha_{m}\right)$，令$L(w,b,\boldsymbol{\alpha})$对$w$和$b$的偏导为零可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\boldsymbol{w} &=\sum_{i=1}^{m} \alpha_{i} y_{i} \boldsymbol{x}_{i} \\
0 &=\sum_{i=1}^{m} \alpha_{i} y_{i}
\end{aligned}</script><p>再将上式代入该问题的拉格朗日函数可以得到SVM基本型的对偶问题：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\max _{\alpha} \sum_{i=1}^{m} \alpha_{i}-\frac{1}{2} \sum_{i=1}^{m} \sum_{j=1}^{m} \alpha_{i} \alpha_{j} y_{i} y_{j} \boldsymbol{x}_{i}^{\mathrm{T}} \boldsymbol{x}_{j} \\
\text { s.t. } \quad \sum_{i=1}^{m} \alpha_{i} y_{i}=0, \\
\quad \alpha_{i} \geqslant 0, \quad i=1,2, \ldots, m .
\end{array}</script><p>用SMO算法解出$\boldsymbol{\alpha}$后，求出$w$和$b$即可得到模型</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(\boldsymbol{x}) &=\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}+b \\
&=\sum_{i=1}^{m} \alpha_{i} y_{i} \boldsymbol{x}_{i}^{\mathrm{T}} \boldsymbol{x}+b
\end{aligned}</script><p>上述过程要满足上 KKT(Karush-Kuhn-Tucker) 条件，即要求：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
\alpha_{i} \geqslant 0 \\
y_{i} f\left(\boldsymbol{x}_{i}\right)-1 \geqslant 0 \\
\alpha_{i}\left(y_{i} f\left(\boldsymbol{x}_{i}\right)-1\right)=0
\end{array}\right.</script><p>求解的过程复杂繁琐，为了节省时间，人们通过利用问题本身的特性，提出了很多高效算法， SMO (Sequential Minimal Optimization) 是其中一个著名的代表</p>
<ul>
<li><p>SMO 的基本思路是先固定$\alpha_{i}$之外的所有参数，然后求$\alpha_{i}$上的极值。由于存在约束$\sum_{i=1}^{m} \alpha_{i} y_{i}=0$，若固定$\alpha_{i}$之外的其他变量，则$\alpha_{i}$可由其他变量导出。于是SMO每次选择两个变量$\alpha_{i}$和$\alpha_{j}$，并固定其他参数，这样在参数初始化后不断执行如下两个步骤直至收敛：</p>
<ol>
<li><p>选取一对需要更新的变量$\alpha_{i}$和$\alpha_{j}$，为什么选两个因为他们之间仍然存在关系可以代换，于是n个参数的更新就可以退化为求解一个参数更新两个函数的问题。</p>
</li>
<li><p>固定$\alpha_{i}$和$\alpha_{j}$以外的函数，继续求解：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\max _{\alpha} \sum_{i=1}^{m} \alpha_{i}-\frac{1}{2} \sum_{i=1}^{m} \sum_{j=1}^{m} \alpha_{i} \alpha_{j} y_{i} y_{j} \boldsymbol{x}_{i}^{\mathrm{T}} \boldsymbol{x}_{j} \\
\text { s.t. } \quad \sum_{i=1}^{m} \alpha_{i} y_{i}=0, \\
\quad \alpha_{i} \geqslant 0, \quad i=1,2, \ldots, m .
\end{array}</script></li>
</ol>
</li>
</ul>
<p>SMO算法之所以高效，是由于在固定其他参数后，仅优化两个参数的过程能做到非常高效，具体来说，仅考虑$\alpha_{i}$和$\alpha_{j}$时上式可以重写为$\alpha_{i} y_{i}+\alpha_{j} y_{j}=c, \quad \alpha_{i} \geqslant 0, \quad \alpha_{j} \geqslant 0$</p>
<p>其中$c=-\sum_{k \neq i, j} \alpha_{k} y_{k}$是使得$\sum_{i=1}^{m} \alpha_{i} y_{i}=0$成立的常数，用$\alpha_{i} y_{i}+\alpha_{j} y_{j}=c$消去$\alpha_{j}$，则可以得到一个关于$\alpha_{i}$的单变量二次规划问题，仅有的约束是$\alpha_{i} \geqslant 0$,很容易发现这样的二次规划问题具有闭式解，于是不必调用数值优化算法即可高效的计算出更新后的$\alpha_{i}$和$\alpha_{j}$</p>
<p>关于确定偏移项$b$，要知对于任意的支持向量$(x_s,y_s)$都有$y_sf(x_s)=1$即：</p>
<script type="math/tex; mode=display">
y_{s}\left(\sum_{i \in S} \alpha_{i} y_{i} \boldsymbol{x}_{i}^{\mathrm{T}} \boldsymbol{x}_{s}+b\right)=1</script><p>其中$S=\left\{i \mid \alpha_{i}&gt;0, i=1,2, \ldots, m\right\}$为所有支持向量的下标集，理论上，可选取任意支持向量求解上式来获得b，但实际上有一种更优的方法:也就是使用所有支持向量求解的平均值</p>
<script type="math/tex; mode=display">
b=\frac{1}{|S|} \sum_{s \in S}\left(y_{s}-\sum_{i \in S} \alpha_{i} y_{i} \boldsymbol{x}_{i}^{\mathrm{T}} \boldsymbol{x}_{s}\right)</script><h2 id="SVM的法宝——核函数"><a href="#SVM的法宝——核函数" class="headerlink" title="SVM的法宝——核函数"></a>SVM的法宝——核函数</h2><p>在本章前面的讨论中，我们假设训练样本是线性可分的，即存在一个划分超平面能将训练样本正确分类。然而在现实任务中，原始样本空间内也许并不存在一个能正确划分两类样本的超平面。例如图 6.3 中的“异或“问题就不是线性可分的。</p>
<p><img src="C:\Users\10474\AppData\Roaming\Typora\typora-user-images\image-20211127212844440.png" alt="image-20211127212844440"></p>
<p>这样可以将样本从原始空间映射到更高维度的特征空间中，使得样本在升维后的特征空间内变得线性可分，例如图6.3中就是这样的。如果原始空间是有限维度，即属性数有限，那么一定存在更高维度特征空间使样本可分。</p>
<p>令$\phi(\boldsymbol{x})$表示$x$映射后的特征向量，于是超平面可以表示为：</p>
<script type="math/tex; mode=display">
f(\boldsymbol{x})=\boldsymbol{w}^{\mathrm{T}} \phi(\boldsymbol{x})+b</script><p>其中$w$和$b$是模型的参数，使用有：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\min _{\boldsymbol{w}, b} \frac{1}{2}\|\boldsymbol{w}\|^{2} \\
\text { s.t. } y_{i}\left(\boldsymbol{w}^{\mathrm{T}} \phi(\boldsymbol{x})+b\right) \geqslant 1, \quad i=1,2, \ldots, m
\end{array}</script><p>则其对偶问题为： </p>
<script type="math/tex; mode=display">
\begin{array}{ll}
\max _{\alpha} \sum_{i=1}^{m} \alpha_{i}-\frac{1}{2} \sum_{i=1}^{m} \sum_{j=1}^{m} \alpha_{i} \alpha_{j} y_{i} y_{j} \phi\left(\boldsymbol{x}_{i}\right)^{\mathrm{T}} \phi\left(\boldsymbol{x}_{j}\right) \\
\text { s.t. }  \sum_{i=1}^{m} \alpha_{i} y_{i}=0 \\
 \alpha_{i} \geqslant 0, \quad i=1,2, \ldots, m
\end{array}</script><p>求解上式会涉及到计算$\phi\left(\boldsymbol{x}_{i}\right)^{\mathrm{T}} \phi\left(\boldsymbol{x}_{j}\right) $，这是样本$x_i$与$x_j$映射到特征空间之后的内积，由于特征空间维度可能会很高甚至无穷维，因此计算$\phi\left(\boldsymbol{x}_{i}\right)^{\mathrm{T}} \phi\left(\boldsymbol{x}_{j}\right) $通常是很困难的，为了避开这个麻烦可以设这么一个函数：</p>
<script type="math/tex; mode=display">
\kappa\left(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}\right)=\left\langle\phi\left(\boldsymbol{x}_{i}\right), \phi\left(\boldsymbol{x}_{j}\right)\right\rangle=\phi\left(\boldsymbol{x}_{i}\right)^{\mathrm{T}} \phi\left(\boldsymbol{x}_{j}\right)</script><p>即用一个函数$\kappa\left(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}\right)$来表示他们的内积，即跳过了他们高纬甚至无穷维特征空间中的内积，于是上面的对偶问题又可重写为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\max _{\alpha} & \sum_{i=1}^{m} \alpha_{i}-\frac{1}{2} \sum_{i=1}^{m} \sum_{j=1}^{m} \alpha_{i} \alpha_{j} y_{i} y_{j} \kappa\left(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}\right) \\
\text { s.t. } & \sum_{i=1}^{m} \alpha_{i} y_{i}=0 \\
& \alpha_{i} \geqslant 0, \quad i=1,2, \ldots, m
\end{aligned}</script><p>求解后可以得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(\boldsymbol{x}) &=\boldsymbol{w}^{\mathrm{T}} \phi(\boldsymbol{x})+b \\
&=\sum_{i=1}^{m} \alpha_{i} y_{i} \phi\left(\boldsymbol{x}_{i}\right)^{\mathrm{T}} \phi(\boldsymbol{x})+b \\
&=\sum_{i=1}^{m} \alpha_{i} y_{i} \kappa\left(\boldsymbol{x}, \boldsymbol{x}_{i}\right)+b
\end{aligned}</script><p>这里的$\kappa\left(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}\right)$​就是核函数（kernel function），上式的最优解可以通过训练样本的核函数展开，这一展示又称为”支持向量展式“(support vector expansion). 那么我们该如何选取好的核函数呢？</p>
<p>核函数$\kappa\left(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}\right)$是定义在$x *x$上的对称函数，则$\kappa$是当且仅当任意数据$D=\left\{\boldsymbol{x}_{1}, \boldsymbol{x}_{2}, \ldots, \boldsymbol{x}_{m}\right\}$，”核矩阵“K总是半正定的：</p>
<script type="math/tex; mode=display">
\mathbf{K}=\left[\begin{array}{ccccc}
\kappa\left(\boldsymbol{x}_{1}, \boldsymbol{x}_{1}\right) & \cdots & \kappa\left(\boldsymbol{x}_{1}, \boldsymbol{x}_{j}\right) & \cdots & \kappa\left(\boldsymbol{x}_{1}, \boldsymbol{x}_{m}\right) \\
\vdots & \ddots & \vdots & \ddots & \vdots \\
\kappa\left(\boldsymbol{x}_{i}, \boldsymbol{x}_{1}\right) & \cdots & \kappa\left(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}\right) & \cdots & \kappa\left(\boldsymbol{x}_{i}, \boldsymbol{x}_{m}\right) \\
\vdots & \ddots & \vdots & \ddots & \vdots \\
\kappa\left(\boldsymbol{x}_{m}, \boldsymbol{x}_{1}\right) & \cdots & \kappa\left(\boldsymbol{x}_{m}, \boldsymbol{x}_{j}\right) & \cdots & \kappa\left(\boldsymbol{x}_{m}, \boldsymbol{x}_{m}\right)
\end{array}\right]</script><p>只要一个对称函数所对应的核矩阵半正定，它就能作为核函数使用</p>
<p>我们希望样本在特征空间内线性可分，因此特征空间的好坏对支持向量机的性能至关重要。需注意的是，在不知道特征映射的形式时，我们并不知道什么样的核函数是合适的，而核函数也仅是隐式地定义了这个特征空间.于是，”核函数选择”成为支持向量机的最大变数.若核函数选择不合适，则意味着将样本映射到了一个不合适的特征空间，很可能导致性能不佳.</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\text { 常用核函数 }\\
\begin{array}{lll}
\hline \text { 名称 } & \text { 表达式 } & \text { 参数 } \\
\hline \text { 线性核 } & \kappa\left(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}\right)=\boldsymbol{x}_{i}^{\mathrm{T}} \boldsymbol{x}_{j} & \\
\text { 多项式核 } & \kappa\left(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}\right)=\left(\boldsymbol{x}_{i}^{\mathrm{T}} \boldsymbol{x}_{j}\right)^{d} & d \geqslant 1 \text { 为多项式的次数 } \\
\text { 高斯(径向基)核 } & \kappa\left(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}\right)=\exp \left(-\frac{\left\|\boldsymbol{x}_{i}-\boldsymbol{x}_{j}\right\|^{2}}{2 \sigma^{2}}\right) & \sigma>0 \text { 为高斯核的带宽 }(\text { width }) . \\
\text { 拉普拉斯核 } & \kappa\left(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}\right)=\exp \left(-\frac{\left\|\boldsymbol{x}_{i}-\boldsymbol{x}_{j}\right\|}{\sigma}\right) & \sigma>0 \\
\text { Sigmoid 核 } & \kappa\left(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}\right)=\tanh \left(\beta \boldsymbol{x}_{i}^{\mathrm{T}} \boldsymbol{x}_{j}+\theta\right) & \tanh \text { 为双曲正切函数, } \beta>0, \theta<0 \\
\hline
\end{array}
\end{array}</script><h2 id="SVM的代码实现"><a href="#SVM的代码实现" class="headerlink" title="SVM的代码实现"></a>SVM的代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets, svm</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_moons, make_circles, make_classification</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X, y = make_circles(noise=<span class="number">0.2</span>, factor=<span class="number">0.5</span>, random_state=<span class="number">1</span>);</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">X = StandardScaler().fit_transform(X)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line">cm = plt.cm.RdBu</span><br><span class="line">cm_bright = ListedColormap([<span class="string">&#x27;#FF0000&#x27;</span>, <span class="string">&#x27;#0000FF&#x27;</span>])</span><br><span class="line">ax = plt.subplot()</span><br><span class="line"></span><br><span class="line">ax.set_title(<span class="string">&quot;Input data&quot;</span>)</span><br><span class="line"><span class="comment"># Plot the training points</span></span><br><span class="line">ax.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, cmap=cm_bright)</span><br><span class="line">ax.set_xticks(())</span><br><span class="line">ax.set_yticks(())</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line">grid = GridSearchCV(SVC(), param_grid=&#123;<span class="string">&quot;C&quot;</span>:[<span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>], <span class="string">&quot;gamma&quot;</span>: [<span class="number">1</span>, <span class="number">0.1</span>, <span class="number">0.01</span>]&#125;, cv=<span class="number">4</span>)</span><br><span class="line">grid.fit(X, y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The best parameters are %s with a score of %0.2f&quot;</span></span><br><span class="line">      % (grid.best_params_, grid.best_score_))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">x_min, x_max = X[:, <span class="number">0</span>].<span class="built_in">min</span>() - <span class="number">1</span>, X[:, <span class="number">0</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line">y_min, y_max = X[:, <span class="number">1</span>].<span class="built_in">min</span>() - <span class="number">1</span>, X[:, <span class="number">1</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line">xx, yy = np.meshgrid(np.arange(x_min, x_max,<span class="number">0.02</span>),</span><br><span class="line">                     np.arange(y_min, y_max, <span class="number">0.02</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, C <span class="keyword">in</span> <span class="built_in">enumerate</span>((<span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>)):</span><br><span class="line">    <span class="keyword">for</span> j, gamma <span class="keyword">in</span> <span class="built_in">enumerate</span>((<span class="number">1</span>, <span class="number">0.1</span>, <span class="number">0.01</span>)):</span><br><span class="line">        plt.subplot()       </span><br><span class="line">        clf = SVC(C=C, gamma=gamma)</span><br><span class="line">        clf.fit(X,y)</span><br><span class="line">        Z = clf.predict(np.c_[xx.ravel(), yy.ravel()])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Put the result into a color plot</span></span><br><span class="line">        Z = Z.reshape(xx.shape)</span><br><span class="line">        plt.contourf(xx, yy, Z, cmap=plt.cm.coolwarm, alpha=<span class="number">0.8</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Plot also the training points</span></span><br><span class="line">        plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, cmap=plt.cm.coolwarm)</span><br><span class="line"></span><br><span class="line">        plt.xlim(xx.<span class="built_in">min</span>(), xx.<span class="built_in">max</span>())</span><br><span class="line">        plt.ylim(yy.<span class="built_in">min</span>(), yy.<span class="built_in">max</span>())</span><br><span class="line">        plt.xticks(())</span><br><span class="line">        plt.yticks(())</span><br><span class="line">        plt.xlabel(<span class="string">&quot; gamma=&quot;</span> + <span class="built_in">str</span>(gamma) + <span class="string">&quot; C=&quot;</span> + <span class="built_in">str</span>(C))</span><br><span class="line">        plt.show()</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Minmin</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
